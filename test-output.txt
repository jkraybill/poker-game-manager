
> @jkraybill/poker-game-manager@1.0.0 test
> vitest --run

â–² [WARNING] The condition "types" here will never be used as it comes after both "import" and "require" [package.json]

    package.json:52:6:
      52 â”‚       "types": "./packages/core/src/index.d.ts"
         â•µ       ~~~~~~~

  The "import" condition comes earlier and will be used for all "import" statements:

    package.json:50:6:
      50 â”‚       "import": "./packages/core/src/index.js",
         â•µ       ~~~~~~~~

  The "require" condition comes earlier and will be used for all "require" calls:

    package.json:51:6:
      51 â”‚       "require": "./dist/index.cjs",
         â•µ       ~~~~~~~~~


 RUN  v3.2.4 /home/jkraybill/poker/slack-poker-bot

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should eliminate players in correct order when multiple players bust in same hand
Starting stacks:
  Small Stack (OGcH_Uq2zwqu7qMWCf_ZL): 30 chips
  Medium Stack (rkBhnIl_JLGmTUt3an4-M): 50 chips
  Big Stack (tokwG_0pUKYLTeYCgqhOR): 200 chips

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should eliminate players in correct order when multiple players bust in same hand
Hand ended, winners: [ { name: [32m'Big Stack'[39m, id: [32m'tokwG_0pUKYLTeYCgqhOR'[39m, amount: [33m160[39m } ]

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should eliminate players in correct order when multiple players bust in same hand
Small Stack (OGcH_Uq2zwqu7qMWCf_ZL) eliminated with 0 chips (started with 30)

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should eliminate players in correct order when multiple players bust in same hand
Medium Stack (rkBhnIl_JLGmTUt3an4-M) eliminated with 0 chips (started with 50)

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should eliminate players in correct order when multiple players bust in same hand

Elimination order: [
  {
    playerId: [32m'OGcH_Uq2zwqu7qMWCf_ZL'[39m,
    playerName: [32m'Small Stack'[39m,
    finalChips: [33m0[39m,
    startingChips: [33m30[39m
  },
  {
    playerId: [32m'rkBhnIl_JLGmTUt3an4-M'[39m,
    playerName: [32m'Medium Stack'[39m,
    finalChips: [33m0[39m,
    startingChips: [33m50[39m
  }
]

ğŸ¯ Multiple eliminations detected!
Tournament rule: Players should be eliminated in order of starting stack size
(smallest stack = lowest finishing position = eliminated first)
  Elimination 1: Small Stack (started with 30 chips)
  Elimination 2: Medium Stack (started with 50 chips)
âœ… Correct order: Small Stack eliminated before Medium Stack
âœ… Issue #28 reproduction test completed

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should demonstrate the potential issue with simultaneous eliminations
Players added in this order:
  1. Winner (300 chips)
  2. Big Stack (100 chips)
  3. Medium Stack (60 chips)
  4. Small Stack (40 chips)

Tournament rule: Elimination should be by stack size, not addition order
Expected elimination order: Small -> Medium -> Big

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should demonstrate the potential issue with simultaneous eliminations
[1754206370192] Small Stack eliminated (started with 40 chips)

stdout | packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should demonstrate the potential issue with simultaneous eliminations

Hand ended, winners: [ { name: [32m'Winner'[39m, amount: [33m500[39m } ]

Actual elimination order:
  1. Small Stack (40 chips)
âœ… Simultaneous elimination test completed

 â¯ packages/core/src/integration/elimination-ordering.test.js (3 tests | 1 failed) 256ms
   âœ“ Tournament Elimination Ordering (Issue #28) > should eliminate players in correct order when multiple players bust in same hand 217ms
   âœ“ Tournament Elimination Ordering (Issue #28) > should demonstrate the potential issue with simultaneous eliminations 13ms
   Ã— Tournament Elimination Ordering (Issue #28) > should handle single elimination correctly (baseline test) 25ms
     â†’ expected 230 to be 60 // Object.is equality
 âœ“ packages/core/src/integration/7player-scenarios-v2.test.js (5 tests) 59ms
 âœ“ packages/core/src/integration/6player-scenarios-v2.test.js (5 tests) 60ms
stdout | packages/core/src/integration/split-pot-scenarios-v2.test.js > Split Pot Scenarios (v2) > should handle split main pot with side pot going to different player
Winners: [
  {
    playerId: [32m'Us30aM4TbF_d3iW0wKtxu'[39m,
    amount: [33m300[39m,
    hand: [32m'Straight, K High'[39m
  }
]

 âœ“ packages/core/src/integration/split-pot-scenarios-v2.test.js (4 tests) 46ms
 âœ“ packages/core/src/integration/dead-button-scenarios.test.js (8 tests) 169ms
 âœ“ packages/core/src/integration/8player-scenarios-v2.test.js (4 tests) 49ms
 âœ“ packages/core/src/game/Deck.test.js (29 tests) 477ms
   âœ“ Deck > Fisher-Yates algorithm verification > should implement proper Fisher-Yates shuffle  365ms
 âœ“ packages/core/src/PokerGameManager.test.js (32 tests) 21ms
stdout | packages/core/src/integration/elimination-ordering-v2.test.js > Tournament Elimination Ordering (Issue #28) - v2 > should eliminate players in correct order when multiple players bust in same hand
Starting stacks:
  Small Stack (Mn0BPIkYouo8SEveJ1ZLq): 30 chips
  Medium Stack (BjKzECtPIy2N6MqZlHZZc): 50 chips
  Big Stack (zLq72eurhQdGJtiuV3aXs): 200 chips

stdout | packages/core/src/integration/elimination-ordering-v2.test.js > Tournament Elimination Ordering (Issue #28) - v2 > should eliminate players in correct order when multiple players bust in same hand
Hand ended, winners: [ { name: [32m'Big Stack'[39m, id: [32m'zLq72eurhQdGJtiuV3aXs'[39m, amount: [33m15[39m } ]

Elimination order: []
Only 0 elimination(s) - expected multiple
âœ… Issue #28 reproduction test completed

stdout | packages/core/src/integration/elimination-ordering-v2.test.js > Tournament Elimination Ordering (Issue #28) - v2 > should demonstrate the potential issue with simultaneous eliminations
Players added in this order:
  1. Winner (300 chips)
  2. Big Stack (100 chips)
  3. Medium Stack (60 chips)
  4. Small Stack (40 chips)

Tournament rule: Elimination should be by stack size, not addition order
Expected elimination order: Small -> Medium -> Big

stdout | packages/core/src/integration/elimination-ordering-v2.test.js > Tournament Elimination Ordering (Issue #28) - v2 > should demonstrate the potential issue with simultaneous eliminations

Hand ended, winners: [ { name: [32m'Medium Stack'[39m, amount: [33m15[39m } ]

Actual elimination order:
âœ… Simultaneous elimination test completed

stdout | packages/core/src/integration/elimination-ordering-v2.test.js > Tournament Elimination Ordering (Issue #28) - v2 > should handle single elimination correctly (baseline test)
Survivor has chips: undefined
âœ… Single elimination works correctly

 âœ“ packages/core/src/integration/elimination-ordering-v2.test.js (3 tests) 526ms
stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise

Chip amounts after adding players:
Button/P1: 2000 chips
SB/P2: 2000 chips
BB/P3: 250 chips

Starting game...

--- Action 1 ---
Player P1 to act. Current bet: 100, My bet: 0, Chips: 2000
Valid actions: FOLD, CALL, RAISE, ALL_IN
Can raise: YES
P1 facing bet of 100, need to call 100
P1: Raising is valid, attempting raise
P1 decides: RAISE 200

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p1 action: RAISE 200

--- Action 2 ---
Player P2 to act. Current bet: 200, My bet: 50, Chips: 1950
P2 decides: CALL

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p2 action: CALL 150

--- Action 3 ---
Player P3 to act. Current bet: 200, My bet: 100, Chips: 150
P3 decides: ALL_IN 150

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p3 action: ALL_IN 150

DEBUG: All-in analysis for BB/P3:
  Current bet: 200
  Player's current bet: 100
  Player's chips: 150
  Total bet after all-in: 250
  Raise increment: 50
  Min raise increment: 100
  Will reopen betting: NO

--- Action 4 ---
Player P1 to act. Current bet: 250, My bet: 200, Chips: 1800
Valid actions: FOLD, CALL, ALL_IN
Can raise: NO
P1 facing bet of 250, need to call 50
P1: Cannot raise (not in valid actions), calling instead
P1 decides: CALL

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p1 action: CALL 50

--- Action 5 ---
Player P2 to act. Current bet: 250, My bet: 200, Chips: 1800
P2 decides: CALL

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p2 action: CALL 50

--- Action 6 ---
Player P2 to act. Current bet: 0, My bet: 0, Chips: 1750
P2 decides: CHECK

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p2 action: CHECK 

--- Action 7 ---
Player P1 to act. Current bet: 0, My bet: 0, Chips: 1750
Valid actions: FOLD, CHECK, BET, ALL_IN
Can raise: NO
P1 decides: CHECK

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p1 action: CHECK 

--- Action 8 ---
Player P2 to act. Current bet: 0, My bet: 0, Chips: 1750
P2 decides: CHECK

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p2 action: CHECK 

--- Action 9 ---
Player P1 to act. Current bet: 0, My bet: 0, Chips: 1750
Valid actions: FOLD, CHECK, BET, ALL_IN
Can raise: NO
P1 decides: CHECK

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p1 action: CHECK 

--- Action 10 ---
Player P2 to act. Current bet: 0, My bet: 0, Chips: 1750
P2 decides: CHECK

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p2 action: CHECK 

--- Action 11 ---
Player P1 to act. Current bet: 0, My bet: 0, Chips: 1750
Valid actions: FOLD, CHECK, BET, ALL_IN
Can raise: NO
P1 decides: CHECK

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise
Player p1 action: CHECK 

stdout | packages/core/src/integration/betting-reopening-simple.test.js > Issue #32 - Betting Reopening Rules > should NOT allow re-raise when all-in is less than minimum raise

Hand ended. Winners: [
  {
    playerId: [32m'p1'[39m,
    hand: {
      rank: [33m3[39m,
      kickers: [36m[Array][39m,
      cards: [36m[Array][39m,
      description: [32m"Two Pair, 7's & 5's"[39m
    },
    cards: [ [36m[Object][39m, [36m[Object][39m ],
    amount: [33m750[39m
  }
]

=== ANALYSIS ===
Total actions: [33m11[39m
All actions: [
  {
    playerId: [32m'p1'[39m,
    action: [32m'RAISE'[39m,
    amount: [33m200[39m,
    timestamp: [33m1754206372024[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p2'[39m,
    action: [32m'CALL'[39m,
    amount: [33m150[39m,
    timestamp: [33m1754206372024[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p3'[39m,
    action: [32m'ALL_IN'[39m,
    amount: [33m150[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CALL'[39m,
    amount: [33m50[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p2'[39m,
    action: [32m'CALL'[39m,
    amount: [33m50[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p2'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'FLOP'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'FLOP'[39m
  },
  {
    playerId: [32m'p2'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'TURN'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372026[39m,
    phase: [32m'TURN'[39m
  },
  {
    playerId: [32m'p2'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372026[39m,
    phase: [32m'RIVER'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372026[39m,
    phase: [32m'RIVER'[39m
  }
]

P1 actions: [
  {
    playerId: [32m'p1'[39m,
    action: [32m'RAISE'[39m,
    amount: [33m200[39m,
    timestamp: [33m1754206372024[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CALL'[39m,
    amount: [33m50[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'FLOP'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372026[39m,
    phase: [32m'TURN'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372026[39m,
    phase: [32m'RIVER'[39m
  }
]

P3 went all-in for 150
P1 actions after P3 all-in: [
  {
    playerId: [32m'p1'[39m,
    action: [32m'CALL'[39m,
    amount: [33m50[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372025[39m,
    phase: [32m'FLOP'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372026[39m,
    phase: [32m'TURN'[39m
  },
  {
    playerId: [32m'p1'[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372026[39m,
    phase: [32m'RIVER'[39m
  }
]
GOOD: P1 was not allowed to raise after small all-in

 âœ“ packages/core/src/integration/betting-reopening-simple.test.js (2 tests) 26ms
stdout | packages/core/src/integration/betting-reopening-simple-v2.test.js > Issue #32 - Betting Reopening Rules (v2) > should NOT allow re-raise when all-in is less than minimum raise

Chip amounts after setting:
Button/P1: 2000 chips
SB/P2: 2000 chips
BB/P3: 250 chips

Starting game...

--- Action 1 ---
Player p1 action: FOLD 
Player p2 action: FOLD 

stdout | packages/core/src/integration/betting-reopening-simple-v2.test.js > Issue #32 - Betting Reopening Rules (v2) > should NOT allow re-raise when all-in is less than minimum raise

Hand ended. Winners: [
  {
    playerId: [32m'p3'[39m,
    hand: [32m'Won by fold'[39m,
    cards: [ [36m[Object][39m, [36m[Object][39m ],
    amount: [33m150[39m
  }
]

=== ANALYSIS ===
Total actions: [33m2[39m
All actions: [
  {
    playerId: [32m'p1'[39m,
    action: [32m'FOLD'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372091[39m,
    phase: [32m'PRE_FLOP'[39m
  },
  {
    playerId: [32m'p2'[39m,
    action: [32m'FOLD'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372091[39m,
    phase: [32m'PRE_FLOP'[39m
  }
]

P1 actions: [
  {
    playerId: [32m'p1'[39m,
    action: [32m'FOLD'[39m,
    amount: [90mundefined[39m,
    timestamp: [33m1754206372091[39m,
    phase: [32m'PRE_FLOP'[39m
  }
]

stdout | packages/core/src/integration/betting-reopening-simple-v2.test.js > Issue #32 - Betting Reopening Rules (v2) > should ALLOW re-raise when all-in is a full raise or more

Chip amounts after setting:
Button/P1: 2000 chips
SB/P2: 2000 chips
BB/P3: 400 chips

Starting game...

stdout | packages/core/src/integration/betting-reopening-simple-v2.test.js > Issue #32 - Betting Reopening Rules (v2) > should ALLOW re-raise when all-in is a full raise or more
P3 strategy: chips=300, bet=100

 âœ“ packages/core/src/integration/betting-reopening-simple-v2.test.js (2 tests) 15ms
stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
=== TEST 1: Starting betting details test ===
[Player 1] strategyType=raise, toCall=20, phase=PRE_FLOP
[Player 1] Betting 50

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 2] strategyType=call, toCall=40, phase=PRE_FLOP
[Player 2] Calling 40

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 3] strategyType=check, toCall=30, phase=PRE_FLOP
[Player 3] Folding

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 2] strategyType=call, toCall=0, phase=FLOP
[Player 2] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 1] strategyType=raise, toCall=0, phase=FLOP
[Player 1] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 2] strategyType=call, toCall=0, phase=TURN
[Player 2] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 1] strategyType=raise, toCall=0, phase=TURN
[Player 1] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 2] strategyType=call, toCall=0, phase=RIVER
[Player 2] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
[Player 1] strategyType=raise, toCall=0, phase=RIVER
[Player 1] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
=== TEST 1: Completed successfully ===

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should include betting details in action:requested event
=== afterEach: Cleaning up ===
=== afterEach: Done ===

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should correctly calculate betting details for all-in scenarios
=== Starting all-in scenarios test ===
Starting game...
[Short Stack] Going all-in with 20 chips
Waiting for actions...

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should correctly calculate betting details for all-in scenarios
[Big Stack] Big stack: toCall=15
[Big Stack] Calling 15

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should correctly calculate betting details for all-in scenarios
[Big Stack] Big stack: toCall=0
[Big Stack] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should correctly calculate betting details for all-in scenarios
[Big Stack] Big stack: toCall=0
[Big Stack] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should correctly calculate betting details for all-in scenarios
[Big Stack] Big stack: toCall=0
[Big Stack] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should correctly calculate betting details for all-in scenarios
Checking captured request...

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should correctly calculate betting details for all-in scenarios
=== afterEach: Cleaning up ===
=== afterEach: Done ===

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
=== Starting valid actions test ===
Adding players...
Starting game...
[Player 1] Versatile strategy called: toCall=10, actionCount=1
[Player 1] Calling 10
Waiting for several actions...

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
[Player 2] Versatile strategy called: toCall=0, actionCount=1
[Player 2] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
[Player 2] Versatile strategy called: toCall=0, actionCount=3
[Player 2] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
[Player 1] Versatile strategy called: toCall=0, actionCount=3
[Player 1] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
[Player 2] Versatile strategy called: toCall=0, actionCount=5
[Player 2] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
[Player 1] Versatile strategy called: toCall=0, actionCount=5
[Player 1] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
[Player 2] Versatile strategy called: toCall=0, actionCount=7
[Player 2] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
[Player 1] Versatile strategy called: toCall=0, actionCount=7
[Player 1] Checking

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
Done waiting, checking results...

stdout | packages/core/src/integration/betting-details-v2.test.js > Betting Details in action:requested Event (v2) > should show correct valid actions based on game state
=== afterEach: Cleaning up ===
=== afterEach: Done ===

 âœ“ packages/core/src/integration/betting-details-v2.test.js (3 tests) 718ms
   âœ“ Betting Details in action:requested Event (v2) > should show correct valid actions based on game state  307ms
stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

=== EXACT FAILING SCENARIO ===
P1: [33m100[39m chips
P2: [33m300[39m chips
P3: [33m1000[39m chips
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m10[39m,
  playerBet: { playerId: [32m'p2'[39m, amount: [33m10[39m },
  tableId: [32m'uBlaT2VRHynIR9N8TwD04'[39m,
  gameNumber: [33m1[39m
}
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m30[39m,
  playerBet: { playerId: [32m'p3'[39m, amount: [33m20[39m },
  tableId: [32m'uBlaT2VRHynIR9N8TwD04'[39m,
  gameNumber: [33m1[39m
}
Short Stack: ALL_IN 100

stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

Player action: p1 ALL_IN 100
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m130[39m,
  playerBet: { playerId: [32m'p1'[39m, amount: [33m100[39m },
  tableId: [32m'uBlaT2VRHynIR9N8TwD04'[39m,
  gameNumber: [33m1[39m
}
Medium Stack: ALL_IN 300

stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

Player action: p2 ALL_IN 300
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m220[39m,
  playerBet: { playerId: [32m'p2'[39m, amount: [33m90[39m },
  tableId: [32m'uBlaT2VRHynIR9N8TwD04'[39m,
  gameNumber: [33m1[39m
}
pot:updated event: {
  potId: [33m1[39m,
  potName: [32m'Side Pot 1'[39m,
  total: [33m200[39m,
  playerBet: { playerId: [32m'p2'[39m, amount: [33m200[39m },
  tableId: [32m'uBlaT2VRHynIR9N8TwD04'[39m,
  gameNumber: [33m1[39m
}
Big Stack: CALL 280

stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

Player action: p3 CALL 280
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m300[39m,
  playerBet: { playerId: [32m'p3'[39m, amount: [33m80[39m },
  tableId: [32m'uBlaT2VRHynIR9N8TwD04'[39m,
  gameNumber: [33m1[39m
}
pot:updated event: {
  potId: [33m1[39m,
  potName: [32m'Side Pot 1'[39m,
  total: [33m400[39m,
  playerBet: { playerId: [32m'p3'[39m, amount: [33m200[39m },
  tableId: [32m'uBlaT2VRHynIR9N8TwD04'[39m,
  gameNumber: [33m1[39m
}

stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

Player action: p3 CHECK 

stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

Player action: p3 CHECK 

stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

Player action: p3 CHECK 

stdout | packages/core/src/integration/issue-11-minimal-repro.test.js > Issue #11 - Minimal Pot Distribution Bug > should reproduce the exact failing scenario

=== RESULTS ===
Winners: [
  { id: [32m'p1'[39m, amount: [33m300[39m, hand: [32m"Pair, A's"[39m },
  { id: [32m'p2'[39m, amount: [33m400[39m, hand: [32m"Pair, K's"[39m }
]

Actual Pots: [
  { amount: [33m300[39m, eligible: [ [32m'p1'[39m, [32m'p2'[39m, [32m'p3'[39m ] },
  { amount: [33m400[39m, eligible: [ [32m'p2'[39m, [32m'p3'[39m ] }
]

Expected Pots:
- Main pot: 300, eligible: [p1, p2, p3]
- Side pot: 400, eligible: [p2, p3]

âœ… Bug FIXED: Winner correctly got [33m300[39m chips

=== FINAL CHIP COUNTS ===
P1: [33m300[39m (started with 100)
P2: [33m400[39m (started with 300)
P3: [33m700[39m (started with 1000)

 âœ“ packages/core/src/integration/issue-11-minimal-repro.test.js (1 test) 14ms
 âœ“ packages/core/src/integration/chip-tracking-v2.test.js (3 tests) 35ms
stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
Custom deck length: [33m12[39m
Starting game...
SimplePlayer Player 1 getAction called, phase: PRE_FLOP, currentBet: 20
My state - bet: 10, chips: 990
Player 1 calling 10

stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
SimplePlayer Player 2 getAction called, phase: PRE_FLOP, currentBet: 20
My state - bet: 20, chips: 980
Player 2 checking

stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
SimplePlayer Player 2 getAction called, phase: FLOP, currentBet: 0
My state - bet: 0, chips: 980
Player 2 checking

stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
SimplePlayer Player 1 getAction called, phase: FLOP, currentBet: 0
My state - bet: 0, chips: 980
Player 1 checking

stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
SimplePlayer Player 2 getAction called, phase: TURN, currentBet: 0
My state - bet: 0, chips: 980
Player 2 checking

stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
SimplePlayer Player 1 getAction called, phase: TURN, currentBet: 0
My state - bet: 0, chips: 980
Player 1 checking

stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
SimplePlayer Player 2 getAction called, phase: RIVER, currentBet: 0
My state - bet: 0, chips: 980
Player 2 checking

stdout | packages/core/src/integration/custom-deck-v2.test.js > Custom Deck Tests (v2) > should handle custom deck with exact card count
SimplePlayer Player 1 getAction called, phase: RIVER, currentBet: 0
My state - bet: 0, chips: 980
Player 1 checking

 âœ“ packages/core/src/integration/custom-deck-v2.test.js (2 tests) 25ms
 âœ“ packages/core/src/game/HandEvaluator.test.js (21 tests) 10ms
stdout | packages/core/src/integration/dead-button-advanced.test.js > Dead Button Advanced Scenarios > should ensure no player posts BB twice in a row when SB is eliminated

After Hand 1:
Player chips: [ [32m'A: $undefined'[39m, [32m'B: $30'[39m, [32m'C: $undefined'[39m ]
Blinds posted: { sb: [32m'B'[39m, bb: [32m'C'[39m }

stdout | packages/core/src/integration/dead-button-advanced.test.js > Dead Button Advanced Scenarios > should ensure no player posts BB twice in a row when SB is eliminated

After Hand 2:
Player chips: [ [32m'A: $undefined'[39m, [32m'B: $30'[39m, [32m'C: $undefined'[39m ]
Blinds posted: { sb: [32m'C'[39m, bb: [32m'A'[39m }

Blind posting history:
A: Hand 2 BB
B: Hand 1 SB
C: Hand 1 BB, Hand 2 SB

stdout | packages/core/src/integration/dead-button-advanced.test.js > Dead Button Advanced Scenarios > should ensure no player posts BB twice in a row when SB is eliminated

=== Dead Button Test Result ===
Hand 1 BB: C
Hand 2 BB: A
Did anyone post BB twice? No

stdout | packages/core/src/integration/dead-button-advanced.test.js > Dead Button Advanced Scenarios > should handle button player elimination correctly

=== Button Elimination Test ===
Hand 1 button position: [33m0[39m
Hand 1 active players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
Hand 2 button position: [33m1[39m
Hand 2 active players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]

 âœ“ packages/core/src/integration/dead-button-advanced.test.js (2 tests) 2116ms
   âœ“ Dead Button Advanced Scenarios > should handle button player elimination correctly  2011ms
stdout | packages/core/src/integration/dead-button.test.js > Dead Button Rules > should implement dead button when player between button and blinds is eliminated

=== Dead Button Test Results ===
Hand 1: { sb: [32m'B'[39m, bb: [32m'C'[39m, button: [33m0[39m }
Hand 2: { sb: [32m'C'[39m, bb: [32m'D'[39m, button: [33m1[39m, deadButton: [33mtrue[39m, deadSB: [33mfalse[39m }
Expected: Dead button on position 1, no SB, C posts BB

stdout | packages/core/src/integration/dead-button.test.js > Dead Button Rules > should handle multiple eliminations correctly

=== Multiple Elimination Test ===
Hand data: [
  { hand: [33m1[39m, button: [33m0[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ] },
  { hand: [33m2[39m, button: [33m1[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ] }
]

 âœ“ packages/core/src/integration/dead-button.test.js (2 tests) 361ms
 âœ“ packages/core/src/game/PotManager.test.js (17 tests) 7ms
stdout | packages/core/src/integration/dead-button-v2.test.js > Dead Button Rules (v2) > should implement dead button when player between button and blinds is eliminated

=== Dead Button Test Results ===
Hand 1: { sb: [32m'B'[39m, bb: [32m'C'[39m, button: [33m0[39m }
Hand 2: { sb: [32m'C'[39m, bb: [32m'D'[39m, button: [33m1[39m, deadButton: [33mtrue[39m, deadSB: [33mfalse[39m }
Expected: Dead button on position 1, no SB, C posts BB

stdout | packages/core/src/integration/dead-button-v2.test.js > Dead Button Rules (v2) > should handle multiple eliminations correctly

=== Multiple Elimination Test ===
Hand data: [
  { hand: [33m1[39m, button: [33m0[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ] },
  { hand: [33m2[39m, button: [33m1[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ] }
]

 âœ“ packages/core/src/integration/dead-button-v2.test.js (2 tests) 259ms
 âœ“ packages/core/src/game/GameEngine.test.js (12 tests) 1019ms
   âœ“ GameEngine > player actions > should handle timeout by folding  1004ms
 âœ“ packages/core/src/integration/chopped-blinds-v2.test.js (4 tests) 48ms
 âœ“ packages/core/src/game/PotManager.split-pot.test.js (5 tests) 3ms
stdout | packages/core/src/integration/5player-squeeze-play-v2.test.js > 5-Player Squeeze Play (v2) > should handle SB squeeze play after raise and call
Total actions: [33m7[39m
Actions: [
  { action: [32m'RAISE'[39m, amount: [33m60[39m },
  { action: [32m'FOLD'[39m, amount: [90mundefined[39m },
  { action: [32m'CALL'[39m, amount: [33m60[39m },
  { action: [32m'RAISE'[39m, amount: [33m180[39m },
  { action: [32m'FOLD'[39m, amount: [90mundefined[39m },
  { action: [32m'FOLD'[39m, amount: [90mundefined[39m },
  { action: [32m'FOLD'[39m, amount: [90mundefined[39m }
]

 âœ“ packages/core/src/integration/5player-squeeze-play-v2.test.js (1 test) 14ms
 âœ“ packages/core/src/integration/split-pot-deterministic-v2.test.js (2 tests) 24ms
stdout | packages/core/src/integration/5player-complex-side-pots-v2.test.js > 5-Player Complex Side Pots (v2) > should handle complex side pot with multiple all-ins at different amounts
All actions: [
  { name: [32m'Huge Stack'[39m, chips: [33m1000[39m, action: [32m'RAISE'[39m, amount: [33m400[39m },
  { name: [32m'Large Stack'[39m, chips: [33m500[39m, action: [32m'CALL'[39m, amount: [33m400[39m },
  { name: [32m'Tiny Stack'[39m, chips: [33m50[39m, action: [32m'FOLD'[39m, amount: [90mundefined[39m },
  { name: [32m'Small Stack'[39m, chips: [33m100[39m, action: [32m'ALL_IN'[39m, amount: [33m90[39m },
  { name: [32m'Medium Stack'[39m, chips: [33m300[39m, action: [32m'ALL_IN'[39m, amount: [33m280[39m },
  {
    name: [32m'Huge Stack'[39m,
    chips: [33m1000[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m
  },
  {
    name: [32m'Large Stack'[39m,
    chips: [33m500[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m
  },
  {
    name: [32m'Huge Stack'[39m,
    chips: [33m1000[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m
  },
  {
    name: [32m'Large Stack'[39m,
    chips: [33m500[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m
  },
  {
    name: [32m'Huge Stack'[39m,
    chips: [33m1000[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m
  },
  {
    name: [32m'Large Stack'[39m,
    chips: [33m500[39m,
    action: [32m'CHECK'[39m,
    amount: [90mundefined[39m
  }
]
Side pots created: [33m3[39m
Total pot amount: [33m1200[39m
Winners: [ { playerId: [32m'BAHNdYRRKkr0wXBCmH1GI'[39m, amount: [33m1200[39m } ]

 âœ“ packages/core/src/integration/5player-complex-side-pots-v2.test.js (1 test) 13ms
 âœ“ packages/core/src/integration/5player-family-pot-v2.test.js (1 test) 13ms
stdout | packages/core/src/integration/event-ordering-fixed.test.js > Event Ordering - Fixed (Issue #33) > should fire player:eliminated after hand:ended when player has 0 chips
hand:ended fired, winners: [
  {
    playerId: [32m'poor'[39m,
    hand: [32m'Won by fold'[39m,
    cards: [ [36m[Object][39m, [36m[Object][39m ],
    amount: [33m30[39m
  }
]

stdout | packages/core/src/integration/event-ordering-fixed.test.js > Event Ordering - Fixed (Issue #33) > should fire player:eliminated after hand:ended when player has 0 chips

Event log:
  1. hand:ended at 1754206377405 { event: [32m'hand:ended'[39m, timestamp: [33m1754206377405[39m, winners: [33m1[39m }

No elimination occurred - poor player survived

Final chips: { rich: [33m30[39m, poor: [33m50[39m }

stdout | packages/core/src/integration/event-ordering-fixed.test.js > Event Ordering - Fixed (Issue #33) > should handle multiple eliminations in correct order
hand:ended with [33m1[39m winners

stdout | packages/core/src/integration/event-ordering-fixed.test.js > Event Ordering - Fixed (Issue #33) > should handle multiple eliminations in correct order

Elimination order: []
Event count: [33m1[39m

 âœ“ packages/core/src/integration/event-ordering-fixed.test.js (2 tests) 808ms
   âœ“ Event Ordering - Fixed (Issue #33) > should fire player:eliminated after hand:ended when player has 0 chips  304ms
   âœ“ Event Ordering - Fixed (Issue #33) > should handle multiple eliminations in correct order  504ms
stdout | packages/core/src/integration/standings-display-v2.test.js > Standings Display (Issue #34) - v2 > should separate active and eliminated players in standings
Player Bob (8dQ-6wCTTrHDknDpjlU6x) eliminated (1 total)

stdout | packages/core/src/integration/standings-display-v2.test.js > Standings Display (Issue #34) - v2 > should separate active and eliminated players in standings
Player Alice (JU3_O2oulk9LiiqDKzmKy) eliminated (2 total)

stdout | packages/core/src/integration/standings-display-v2.test.js > Standings Display (Issue #34) - v2 > should separate active and eliminated players in standings
Final standings: {
  active: [ { name: [32m'Charlie'[39m, chips: [33m650[39m } ],
  eliminated: [
    { name: [32m'Bob'[39m, status: [32m'eliminated'[39m },
    { name: [32m'Alice'[39m, status: [32m'eliminated'[39m }
  ],
  summary: { playersRemaining: [33m1[39m, totalChipsInPlay: [33m650[39m, averageStack: [33m650[39m }
}
âœ… Issue #34 fix verified: Eliminated players properly separated from active standings

stdout | packages/core/src/integration/standings-display-v2.test.js > Standings Display (Issue #34) - v2 > should handle all players eliminated scenario
âœ… Edge case handled: All/most players eliminated scenario

 âœ“ packages/core/src/integration/standings-display-v2.test.js (2 tests) 228ms
stdout | packages/core/src/integration/standings-display.test.js > Standings Display (Issue #34) > should separate active and eliminated players in standings
Player Charlie (Xb0rOZBFFFaMYUnVGltgi) eliminated (1 total)

stdout | packages/core/src/integration/standings-display.test.js > Standings Display (Issue #34) > should separate active and eliminated players in standings
Player Alice (N_3IEk1abKUfSafBHc7g2) eliminated (2 total)

stdout | packages/core/src/integration/standings-display.test.js > Standings Display (Issue #34) > should separate active and eliminated players in standings
Final standings: {
  active: [ { name: [32m'Bob'[39m, chips: [33m650[39m } ],
  eliminated: [
    { name: [32m'Charlie'[39m, status: [32m'eliminated'[39m },
    { name: [32m'Alice'[39m, status: [32m'eliminated'[39m }
  ],
  summary: { playersRemaining: [33m1[39m, totalChipsInPlay: [33m650[39m, averageStack: [33m650[39m }
}
âœ… Issue #34 fix verified: Eliminated players properly separated from active standings

stdout | packages/core/src/integration/standings-display.test.js > Standings Display (Issue #34) > should handle all players eliminated scenario
âœ… Edge case handled: All/most players eliminated scenario

 âœ“ packages/core/src/integration/standings-display.test.js (2 tests) 329ms
 âœ“ packages/core/src/integration/button-rotation-v2.test.js (4 tests) 219ms
stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should NOT auto-start games anymore - requires explicit start
ğŸ® Game 1 started
Player EOdzqA7ha-enBZzlIr87J acting in game 1, hand 0

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should NOT auto-start games anymore - requires explicit start
ğŸ Hand 1 ended
â° 5-second timer started for next game...

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should NOT auto-start games anymore - requires explicit start
â³ Waiting 1 second to verify no automatic restart...

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should NOT auto-start games anymore - requires explicit start

ğŸ“Š Final stats:
Games started: 1
Hands ended: 1

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should show why tests capture actions from multiple games
ğŸ“Š Strategy called: actionCount=1, currentBet=20, playerId=58q08IhUn7yjgf6nh90Yk
ğŸ² Returning RAISE action

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should show why tests capture actions from multiple games
ğŸ“ Action detected: RAISE, amount: 60
ğŸ¯ Raise detected! Total raises: 1

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should show why tests capture actions from multiple games
ğŸ“ Action detected: FOLD, amount: undefined
ğŸ Hand ended. Total actions so far: 2

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should show why tests capture actions from multiple games

ğŸ” Actions captured after 1 second:
Total actions: 2
Raises: 1

âœ…  No more automatic restarts - only explicit game starts!

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should show how to prevent the leak with immediate table close
âœ… Game 1 started

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should show how to prevent the leak with immediate table close
âœ… Hand ended, immediately closing table

stdout | packages/core/src/integration/memory-leak-repro-v2.test.js > Table Auto-Start Behavior (v2) > should show how to prevent the leak with immediate table close

âœ… Final game count: 1

 âœ“ packages/core/src/integration/memory-leak-repro-v2.test.js (3 tests) 3554ms
   âœ“ Table Auto-Start Behavior (v2) > should NOT auto-start games anymore - requires explicit start  1523ms
   âœ“ Table Auto-Start Behavior (v2) > should show why tests capture actions from multiple games  1025ms
   âœ“ Table Auto-Start Behavior (v2) > should show how to prevent the leak with immediate table close  1007ms
 âœ“ packages/core/src/integration/table-explicit-start-v2.test.js (5 tests) 1831ms
   âœ“ Table Explicit Start API (v2) > should NOT auto-start games when players join  507ms
   âœ“ Table Explicit Start API (v2) > should NOT auto-restart after hand ends  1015ms
stdout | packages/core/src/integration/button-rotation.test.js > Dealer Button Rotation (Issue #36) > should rotate dealer button clockwise after each hand
Button positions over 5 hands: [ [33m0[39m, [33m1[39m, [33m2[39m, [33m0[39m, [33m1[39m ]

stdout | packages/core/src/integration/button-rotation.test.js > Dealer Button Rotation (Issue #36) > should skip eliminated players when rotating button
Player 2 chips after hand 1: [33m30[39m

stdout | packages/core/src/integration/button-rotation.test.js > Dealer Button Rotation (Issue #36) > should skip eliminated players when rotating button
Button positions: [ [33m0[39m, [33m1[39m, [33m2[39m ]
Active players per hand: [ [33m4[39m, [33m4[39m, [33m4[39m ]

 âœ“ packages/core/src/integration/button-rotation.test.js (2 tests) 567ms
   âœ“ Dealer Button Rotation (Issue #36) > should skip eliminated players when rotating button  307ms
stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should NOT auto-start games anymore - requires explicit start
ğŸ® Game 1 started
Player 4FHW6Jxwj4xrQdYF40mRf acting in game 1, hand 0

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should NOT auto-start games anymore - requires explicit start
ğŸ Hand 1 ended
â° 5-second timer started for next game...

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should NOT auto-start games anymore - requires explicit start
â³ Waiting 1 second to verify no automatic restart...

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should NOT auto-start games anymore - requires explicit start

ğŸ“Š Final stats:
Games started: 1
Hands ended: 1

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should show why tests capture actions from multiple games
ğŸ“Š Strategy called: actionCount=1, currentBet=20, playerId=QiDA1hqE50fyZFrlOXutV
ğŸ² Returning RAISE action

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should show why tests capture actions from multiple games
ğŸ“ Action detected: RAISE, amount: 60
ğŸ¯ Raise detected! Total raises: 1
ğŸ“Š Strategy called: actionCount=1, currentBet=70, playerId=ZeEsKDAb4YZwODg4H4VdF

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should show why tests capture actions from multiple games
ğŸ“ Action detected: FOLD, amount: undefined
ğŸ Hand ended. Total actions so far: 2

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should show why tests capture actions from multiple games

ğŸ” Actions captured after 1 second:
Total actions: 2
Raises: 1

âœ…  No more automatic restarts - only explicit game starts!

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should show how to prevent the leak with immediate table close
âœ… Game 1 started

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should show how to prevent the leak with immediate table close
âœ… Hand ended, immediately closing table

stdout | packages/core/src/integration/memory-leak-repro.test.js > Table Auto-Start Behavior > should show how to prevent the leak with immediate table close

âœ… Final game count: 1

 âœ“ packages/core/src/integration/memory-leak-repro.test.js (3 tests) 3576ms
   âœ“ Table Auto-Start Behavior > should NOT auto-start games anymore - requires explicit start  1536ms
   âœ“ Table Auto-Start Behavior > should show why tests capture actions from multiple games  1027ms
   âœ“ Table Auto-Start Behavior > should show how to prevent the leak with immediate table close  1014ms
 âœ“ packages/core/src/integration/3player-button-raises-bb-calls-folds-flop-v2.test.js (1 test) 14ms
stdout | packages/core/src/integration/event-ordering-verified.test.js > Event Ordering - Verified (Issue #33) > should verify event ordering is correct even without elimination
hand:ended at [33m1754206388888[39m
handleGameEnd called at [33m1754206388888[39m
Time since hand:ended: [33m0[39m ms
Players with 0 chips: [33m0[39m

stdout | packages/core/src/integration/event-ordering-verified.test.js > Event Ordering - Verified (Issue #33) > should verify event ordering is correct even without elimination

Final event log:
  hand:ended at 1754206388888
  handleGameEnd at 1754206388888

stdout | packages/core/src/integration/event-ordering-verified.test.js > Event Ordering - Verified (Issue #33) > should ensure elimination events fire after hand:ended
hand:ended fired with winners: [
  {
    playerId: [32m'poor'[39m,
    hand: {
      rank: [33m3[39m,
      kickers: [36m[Array][39m,
      cards: [36m[Array][39m,
      description: [32m"Two Pair, 3's & 2's"[39m
    },
    cards: [ [36m[Object][39m, [36m[Object][39m ],
    amount: [33m40[39m
  }
]

stdout | packages/core/src/integration/event-ordering-verified.test.js > Event Ordering - Verified (Issue #33) > should ensure elimination events fire after hand:ended

Event log:
  hand:ended {
  event: [32m'hand:ended'[39m,
  winners: [ { playerId: [32m'poor'[39m, hand: [36m[Object][39m, cards: [36m[Array][39m, amount: [33m40[39m } ]
}

 âœ“ packages/core/src/integration/event-ordering-verified.test.js (2 tests) 310ms
stdout | packages/core/src/integration/dead-button-advanced-v2.test.js > Dead Button Advanced Scenarios (v2) > should ensure no player posts BB twice in a row when SB is eliminated

After Hand 1:
Player chips: [ [32m'A: $0'[39m, [32m'B: $30'[39m, [32m'C: $0'[39m ]
Blinds posted: { sb: [32m'B'[39m, bb: [32m'C'[39m }

stdout | packages/core/src/integration/dead-button-advanced-v2.test.js > Dead Button Advanced Scenarios (v2) > should ensure no player posts BB twice in a row when SB is eliminated

After Hand 2:
Player chips: [ [32m'A: $0'[39m, [32m'B: $30'[39m, [32m'C: $0'[39m ]
Blinds posted: { sb: [32m'C'[39m, bb: [32m'A'[39m }

Blind posting history:
A: Hand 2 BB
B: Hand 1 SB
C: Hand 1 BB, Hand 2 SB

=== Dead Button Test Result ===
Hand 1 BB: C
Hand 2 BB: A
Did anyone post BB twice? No

stdout | packages/core/src/integration/dead-button-advanced-v2.test.js > Dead Button Advanced Scenarios (v2) > should handle button player elimination correctly

=== Button Elimination Test ===
Hand 1 button position: [33m0[39m
Hand 1 active players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
Hand 2 button position: [33m1[39m
Hand 2 active players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]

 âœ“ packages/core/src/integration/dead-button-advanced-v2.test.js (2 tests) 1041ms
   âœ“ Dead Button Advanced Scenarios (v2) > should handle button player elimination correctly  1018ms
 âœ“ packages/core/src/integration/4player-bb-defense-v2.test.js (1 test) 13ms
stdout | packages/core/src/integration/eliminated-player-display-v2.test.js > Eliminated Player Display (v2) > should not show eliminated players in active player list
Initial player chips: [
  { id: [32m'A'[39m, chips: [33m200[39m },
  { id: [32m'B'[39m, chips: [33m30[39m },
  { id: [32m'C'[39m, chips: [33m200[39m }
]

stdout | packages/core/src/integration/eliminated-player-display-v2.test.js > Eliminated Player Display (v2) > should not show eliminated players in active player list
Hand 1 ended, active players: [ { id: [32m'A'[39m, chips: [33m260[39m }, { id: [32m'C'[39m, chips: [33m170[39m } ]

stdout | packages/core/src/integration/eliminated-player-display-v2.test.js > Eliminated Player Display (v2) > should not show eliminated players in active player list
Player B eliminated

stdout | packages/core/src/integration/eliminated-player-display-v2.test.js > Eliminated Player Display (v2) > should not show eliminated players in active player list
âœ… Eliminated player not shown in active list
Active players after elimination: A, C
âœ… Issue #34 verified: Eliminated players not in active list

stdout | packages/core/src/integration/eliminated-player-display-v2.test.js > Eliminated Player Display (v2) > should handle all players eliminated scenario
Player p1 eliminated

stdout | packages/core/src/integration/eliminated-player-display-v2.test.js > Eliminated Player Display (v2) > should handle all players eliminated scenario
âœ… Edge case handled: One player remains after heads-up elimination

 âœ“ packages/core/src/integration/eliminated-player-display-v2.test.js (2 tests) 127ms
stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
TEST START: Creating scenario...
Scenario created, getting table and events...
Creating players...
Adding players to scenario...
EVENT: player:joined 
EVENT: player:joined 
EVENT: player:joined 
EVENT: table:ready 
Players added, setting custom chips...
Starting chips: { shortStack: [33m25[39m, medium: [33m100[39m, bigStack: [33m200[39m }
Starting game...
EVENT: game:started 
EVENT: hand:started 
EVENT: cards:dealt UaFREIKy6-pb7vB_YR842
EVENT: cards:dealt btkqJZgjVYvIlHn-jGYVH
EVENT: cards:dealt jYtpfinHg9cNAen15kfBk
EVENT: pot:updated 
EVENT: pot:updated 
EVENT: action:requested for ShortStack (UaFREIKy6-pb7vB_YR842)
Waiting for hand to end...

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from ShortStack - action: FOLD, amount: undefined
EVENT: action:requested for Medium (btkqJZgjVYvIlHn-jGYVH)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from Medium - action: CALL, amount: 10
EVENT: pot:updated 
EVENT: action:requested for BigStack (jYtpfinHg9cNAen15kfBk)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from BigStack - action: CHECK, amount: undefined
EVENT: cards:community 
EVENT: action:requested for Medium (btkqJZgjVYvIlHn-jGYVH)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from Medium - action: CHECK, amount: undefined
EVENT: action:requested for BigStack (jYtpfinHg9cNAen15kfBk)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from BigStack - action: CHECK, amount: undefined
EVENT: cards:community 
EVENT: action:requested for Medium (btkqJZgjVYvIlHn-jGYVH)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from Medium - action: CHECK, amount: undefined
EVENT: action:requested for BigStack (jYtpfinHg9cNAen15kfBk)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from BigStack - action: CHECK, amount: undefined
EVENT: cards:community 
EVENT: action:requested for Medium (btkqJZgjVYvIlHn-jGYVH)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from Medium - action: CHECK, amount: undefined
EVENT: action:requested for BigStack (jYtpfinHg9cNAen15kfBk)

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: player:action from BigStack - action: CHECK, amount: undefined
EVENT: chips:awarded jYtpfinHg9cNAen15kfBk
TRACKED: hand:ended fired
EVENT: hand:ended [33m1[39m

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
Hand ended, waiting for elimination events...

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
Wait complete, analyzing results...
Event log: [ { event: [32m'hand:ended'[39m, timestamp: [33m1754206390540[39m, winners: [33m1[39m } ]
ShortStack still in table? [33mtrue[39m
ShortStack chips: [33m25[39m

stdout | packages/core/src/integration/event-ordering-simple.test.js > Event Ordering - Simple (Issue #33) > should fire player:eliminated after hand:ended
EVENT: table:closed 

 âœ“ packages/core/src/integration/event-ordering-simple.test.js (1 test) 115ms
 âœ“ packages/core/src/game/HandEvaluator.split-pot.test.js (6 tests) 4ms
stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

=== EXACT FAILING SCENARIO ===
P1: [33m100[39m chips (expected 100)
P2: [33m300[39m chips (expected 300)
P3: [33m1000[39m chips (expected 1000)
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m10[39m,
  playerBet: { playerId: [32m'p2'[39m, amount: [33m10[39m },
  tableId: [32m'yOHNc7vq7yqrgppTymEm1'[39m,
  gameNumber: [33m1[39m
}
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m30[39m,
  playerBet: { playerId: [32m'p3'[39m, amount: [33m20[39m },
  tableId: [32m'yOHNc7vq7yqrgppTymEm1'[39m,
  gameNumber: [33m1[39m
}
Short Stack: ALL_IN 100

stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

Player action: p1 ALL_IN 100
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m130[39m,
  playerBet: { playerId: [32m'p1'[39m, amount: [33m100[39m },
  tableId: [32m'yOHNc7vq7yqrgppTymEm1'[39m,
  gameNumber: [33m1[39m
}
Medium Stack: ALL_IN 300

stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

Player action: p2 ALL_IN 290
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m220[39m,
  playerBet: { playerId: [32m'p2'[39m, amount: [33m90[39m },
  tableId: [32m'yOHNc7vq7yqrgppTymEm1'[39m,
  gameNumber: [33m1[39m
}
pot:updated event: {
  potId: [33m1[39m,
  potName: [32m'Side Pot 1'[39m,
  total: [33m200[39m,
  playerBet: { playerId: [32m'p2'[39m, amount: [33m200[39m },
  tableId: [32m'yOHNc7vq7yqrgppTymEm1'[39m,
  gameNumber: [33m1[39m
}
Big Stack: CALL [33m280[39m

stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

Player action: p3 CALL 280
pot:updated event: {
  potId: [33m0[39m,
  potName: [32m'Main Pot'[39m,
  total: [33m300[39m,
  playerBet: { playerId: [32m'p3'[39m, amount: [33m80[39m },
  tableId: [32m'yOHNc7vq7yqrgppTymEm1'[39m,
  gameNumber: [33m1[39m
}
pot:updated event: {
  potId: [33m1[39m,
  potName: [32m'Side Pot 1'[39m,
  total: [33m400[39m,
  playerBet: { playerId: [32m'p3'[39m, amount: [33m200[39m },
  tableId: [32m'yOHNc7vq7yqrgppTymEm1'[39m,
  gameNumber: [33m1[39m
}

stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

Player action: p3 CHECK 

stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

Player action: p3 CHECK 

stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

Player action: p3 CHECK 

stdout | packages/core/src/integration/issue-11-minimal-repro-v2.test.js > Issue #11 - Minimal Pot Distribution Bug (v2) > should reproduce the exact failing scenario

=== RESULTS ===
Winners: [
  { id: [32m'p1'[39m, amount: [33m300[39m, hand: [32m"Pair, A's"[39m },
  { id: [32m'p2'[39m, amount: [33m400[39m, hand: [32m"Pair, K's"[39m }
]

Actual Pots: [
  { amount: [33m300[39m, eligible: [ [32m'p1'[39m, [32m'p2'[39m, [32m'p3'[39m ] },
  { amount: [33m400[39m, eligible: [ [32m'p2'[39m, [32m'p3'[39m ] }
]

Expected Pots:
- Main pot: 300, eligible: [p1, p2, p3]
- Side pot: 400, eligible: [p2, p3]

âœ… Bug FIXED: Winner correctly got [33m300[39m chips

=== FINAL CHIP COUNTS ===
P1: [33m300[39m (started with 100)
P2: [33m400[39m (started with 300)
P3: [33m700[39m (started with 1000)

 âœ“ packages/core/src/integration/issue-11-minimal-repro-v2.test.js (1 test) 14ms
stdout | packages/core/src/integration/elimination-display-fixed.test.js > Elimination Display Fixed > should properly remove eliminated players from active standings

=== HAND 1 STARTED ===

stdout | packages/core/src/integration/elimination-display-fixed.test.js > Elimination Display Fixed > should properly remove eliminated players from active standings

Active players after hand: [
  { id: [32m'A'[39m, name: [32m'Player A (raiser)'[39m, chips: [33m160[39m },
  { id: [32m'C'[39m, name: [32m'Player C (folder)'[39m, chips: [33m80[39m }
]
Total players in table: [33m3[39m
All players in table: [
  { id: [32m'A'[39m, chips: [33m160[39m, inTable: [33mtrue[39m },
  { id: [32m'B'[39m, chips: [33m0[39m, inTable: [33mtrue[39m },
  { id: [32m'C'[39m, chips: [33m80[39m, inTable: [33mtrue[39m }
]

stdout | packages/core/src/integration/elimination-display-fixed.test.js > Elimination Display Fixed > should properly remove eliminated players from active standings

ğŸ”´ ELIMINATION EVENT: Player B eliminated

stdout | packages/core/src/integration/elimination-display-fixed.test.js > Elimination Display Fixed > should properly remove eliminated players from active standings

=== FINAL TEST RESULTS ===
Hands played: [33m1[39m
Eliminations: [33m1[39m
Final active players: [
  { id: [32m'A'[39m, name: [32m'Player A (raiser)'[39m, chips: [33m160[39m },
  { id: [32m'C'[39m, name: [32m'Player C (folder)'[39m, chips: [33m80[39m }
]
Table size: [33m3[39m
Player B in active list: false
Player B still in table.players: true

 âœ“ packages/core/src/integration/elimination-display-fixed.test.js (1 test) 13ms
stdout | packages/core/src/integration/dead-button-v2-fixed.test.js > Dead Button Rules (v2 Fixed) > should demonstrate dead button behavior with player elimination
Set player B chips to 30

Initial player states:
A: 1000 chips
B: 30 chips
C: 1000 chips
D: 1000 chips

Starting first hand...

stdout | packages/core/src/integration/dead-button-v2-fixed.test.js > Dead Button Rules (v2 Fixed) > should demonstrate dead button behavior with player elimination

Hand 1 completed

=== Hand 1 Results ===
Button: [33m0[39m
Players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ]
Blinds: { sb: [32m'B'[39m, bb: [32m'C'[39m }

Player chips after hand 1:
A: 1000 chips
B: 30 chips
C: 1000 chips
D: 1000 chips

Active players: 4
Active player IDs: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ]

Starting second hand...

stdout | packages/core/src/integration/dead-button-v2-fixed.test.js > Dead Button Rules (v2 Fixed) > should demonstrate dead button behavior with player elimination

Hand 2 completed

=== Hand 2 Results ===
Button: [33m1[39m
Players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ]
Blinds: { sb: [32m'C'[39m, bb: [32m'D'[39m }

 âœ“ packages/core/src/integration/dead-button-v2-fixed.test.js (1 test) 23ms
stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
Starting game...
action:requested event #1: { playerId: [32m'button'[39m, phase: [32m'PRE_FLOP'[39m, currentBet: [33m20[39m }
Button getAction called - strategyType: fold, toCall: 20

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #2: { playerId: [32m'sb'[39m, phase: [32m'PRE_FLOP'[39m, currentBet: [33m20[39m }
Small Blind getAction called - strategyType: call, toCall: 10

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #3: { playerId: [32m'bb'[39m, phase: [32m'PRE_FLOP'[39m, currentBet: [33m20[39m }
Big Blind getAction called - strategyType: check, toCall: 0

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #4: { playerId: [32m'sb'[39m, phase: [32m'FLOP'[39m, currentBet: [33m0[39m }
Small Blind getAction called - strategyType: call, toCall: 0

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #5: { playerId: [32m'bb'[39m, phase: [32m'FLOP'[39m, currentBet: [33m0[39m }
Big Blind getAction called - strategyType: check, toCall: 0

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #6: { playerId: [32m'sb'[39m, phase: [32m'TURN'[39m, currentBet: [33m0[39m }
Small Blind getAction called - strategyType: call, toCall: 0

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #7: { playerId: [32m'bb'[39m, phase: [32m'TURN'[39m, currentBet: [33m0[39m }
Big Blind getAction called - strategyType: check, toCall: 0

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #8: { playerId: [32m'sb'[39m, phase: [32m'RIVER'[39m, currentBet: [33m0[39m }
Small Blind getAction called - strategyType: call, toCall: 0

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check
action:requested event #9: { playerId: [32m'bb'[39m, phase: [32m'RIVER'[39m, currentBet: [33m0[39m }
Big Blind getAction called - strategyType: check, toCall: 0

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should only emit action:requested once when big blind has option to check

All action:requested events:
1. Player: button, Phase: PRE_FLOP, CurrentBet: 20
2. Player: sb, Phase: PRE_FLOP, CurrentBet: 20
3. Player: bb, Phase: PRE_FLOP, CurrentBet: 20
4. Player: sb, Phase: FLOP, CurrentBet: 0
5. Player: bb, Phase: FLOP, CurrentBet: 0
6. Player: sb, Phase: TURN, CurrentBet: 0
7. Player: bb, Phase: TURN, CurrentBet: 0
8. Player: sb, Phase: RIVER, CurrentBet: 0
9. Player: bb, Phase: RIVER, CurrentBet: 0

Big blind PRE_FLOP events: 1

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p1 CALL 20

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p2 CALL 10

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p3 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p2 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p3 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p1 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p2 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p3 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p1 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p2 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p3 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls
Player action: p1 CHECK 

stdout | packages/core/src/integration/big-blind-option-v2.test.js > Big Blind Option Events (v2) > should correctly handle big blind option when everyone calls

Player 3 (BB) PRE_FLOP events: 1

 âœ“ packages/core/src/integration/big-blind-option-v2.test.js (2 tests) 25ms
 âœ“ packages/core/src/integration/4player-side-pots-v2.test.js (1 test) 13ms
 âœ“ packages/core/src/integration/4player-utg-button-showdown-v2.test.js (1 test) 13ms
 âœ“ packages/core/src/integration/5player-mp-3bet-v2.test.js (1 test) 13ms
 âœ“ packages/core/src/tests/integration/dealer-button-rotation.test.js (3 tests) 583ms
   âœ“ Dealer Button Rotation > should handle player elimination and continue with reduced players  452ms
stdout | packages/core/src/integration/dead-button-simple.test.js > Dead Button Simple Test > should show that BB moves forward when player is eliminated

=== Dead Button Simple Test Results ===
Hand 1: { button: [33m0[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ], sb: [32m'B'[39m, bb: [32m'C'[39m }
Eliminated: []
Hand 2: { button: [33m1[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ], sb: [32m'C'[39m, bb: [32m'D'[39m }

Expected for Hand 2:
- BB advances from C to D
- Dead button on B's seat
- No SB posted

Actual Hand 2:
- BB posted by: D
- SB posted by: C
- Button position: [33m1[39m

 âœ“ packages/core/src/integration/dead-button-simple.test.js (1 test) 209ms
stdout | packages/core/src/integration/dead-button-simple-v2.test.js > Dead Button Simple Test (v2) > should show that BB moves forward when player is eliminated

=== Dead Button Simple Test Results ===
Hand 1: { button: [33m0[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ], sb: [32m'B'[39m, bb: [32m'C'[39m }
Eliminated: []
Hand 2: { button: [33m1[39m, players: [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m, [32m'D'[39m ], sb: [32m'C'[39m, bb: [32m'D'[39m }

Expected for Hand 2:
- BB advances from C to D
- Dead button on B's seat
- No SB posted

Actual Hand 2:
- BB posted by: D
- SB posted by: C
- Button position: [33m1[39m

 âœ“ packages/core/src/integration/dead-button-simple-v2.test.js (1 test) 15ms
 â¯ packages/core/src/integration/event-ordering-elimination.test.js (1 test | 1 failed) 115ms
   Ã— Event Ordering - Elimination (Issue #33) > should fire player:eliminated after hand:ended when player loses all chips 115ms
     â†’ expected 150 to be 80 // Object.is equality
 âœ“ packages/core/src/integration/4player-button-steal-v2.test.js (1 test) 14ms
stdout | packages/core/src/integration/eliminated-player-display.test.js > Eliminated Player Display > should not show eliminated players in active player list

After hand 1:
Active players: [
  { id: [32m'A'[39m, chips: [33m115[39m },
  { id: [32m'B'[39m, chips: [33m45[39m },
  { id: [32m'C'[39m, chips: [33m70[39m }
]
Table.players size: [33m3[39m
Player B still in table.players with chips: 45

stdout | packages/core/src/integration/eliminated-player-display.test.js > Eliminated Player Display > should not show eliminated players in active player list

=== Elimination Display Test Results ===
Elimination occurred: [33mfalse[39m
Post-elimination active players: [
  { id: [32m'A'[39m, chips: [33m115[39m },
  { id: [32m'B'[39m, chips: [33m45[39m },
  { id: [32m'C'[39m, chips: [33m70[39m }
]
BUG: Eliminated player B still in table with chips: 45

 âœ“ packages/core/src/integration/eliminated-player-display.test.js (1 test) 14ms
stdout | packages/core/src/integration/split-pot-simple-v2.test.js > Simple Split Pot Test (v2) > should handle 2-player all-in split pot scenario
Game started

stdout | packages/core/src/integration/split-pot-simple-v2.test.js > Simple Split Pot Test (v2) > should handle 2-player all-in split pot scenario
hand:ended event received: {
  winners: [
    {
      playerId: [32m'XeeS5cyQ4yMq_F5-HKbxq'[39m,
      hand: [36m[Object][39m,
      cards: [36m[Array][39m,
      amount: [33m2000[39m
    }
  ],
  board: [
    { rank: [32m'9'[39m, suit: [32m'd'[39m, toString: [36m[Function: toString][39m },
    { rank: [32m'2'[39m, suit: [32m'd'[39m, toString: [36m[Function: toString][39m },
    { rank: [32m'7'[39m, suit: [32m'd'[39m, toString: [36m[Function: toString][39m },
    { rank: [32m'4'[39m, suit: [32m'd'[39m, toString: [36m[Function: toString][39m },
    { rank: [32m'4'[39m, suit: [32m'c'[39m, toString: [36m[Function: toString][39m }
  ],
  sidePots: [
    {
      potId: [33m0[39m,
      potName: [32m'Main Pot'[39m,
      amount: [33m2000[39m,
      eligiblePlayers: [36m[Array][39m,
      isMain: [33mtrue[39m,
      isActive: [33mfalse[39m,
      maxContribution: [33m1000[39m
    },
    {
      potId: [33m1[39m,
      potName: [32m'Side Pot 1'[39m,
      amount: [33m0[39m,
      eligiblePlayers: [36m[Array][39m,
      isMain: [33mfalse[39m,
      isActive: [33mfalse[39m,
      maxContribution: [33m1000[39m
    }
  ],
  tableId: [32m'NXpyMs3SjHPJ5YSoxGUuj'[39m,
  gameNumber: [33m1[39m
}
Hand ended with winners: [33m1[39m
Winner details: [
  {
    playerId: [32m'XeeS5cyQ4yMq_F5-HKbxq'[39m,
    handRank: [33m6[39m,
    handKickers: [ [33m10[39m, [33m9[39m, [33m7[39m, [33m4[39m, [33m2[39m ],
    amount: [33m2000[39m
  }
]

stdout | packages/core/src/integration/split-pot-simple-v2.test.js > Simple Split Pot Test (v2) > should handle 2-player all-in split pot scenario
Final winners array: [
  {
    playerId: [32m'XeeS5cyQ4yMq_F5-HKbxq'[39m,
    hand: {
      rank: [33m6[39m,
      kickers: [36m[Array][39m,
      cards: [36m[Array][39m,
      description: [32m'Flush, 10d High'[39m
    },
    cards: [ [36m[Object][39m, [36m[Object][39m ],
    amount: [33m2000[39m
  }
]
Winners length: [33m1[39m

 â¯ packages/core/src/integration/split-pot-simple-v2.test.js (2 tests | 1 failed) 15ms
   âœ“ Simple Split Pot Test (v2) > should properly detect split pot winners in HandEvaluator 1ms
   Ã— Simple Split Pot Test (v2) > should handle 2-player all-in split pot scenario 14ms
     â†’ expected 2000 to be 200 // Object.is equality
 âœ“ packages/core/src/integration/3player-button-raises-blinds-fold-v2.test.js (1 test) 12ms
 âœ“ packages/core/src/integration/3player-scenarios-v2.test.js (1 test) 13ms
 âœ“ packages/core/src/integration/4player-utg-raise-all-fold-v2.test.js (1 test) 12ms
 âœ“ packages/core/src/integration/2player-scenarios-v2.test.js (1 test) 13ms
 âœ“ packages/core/src/integration/fold-scenarios-v2.test.js (1 test) 13ms
stdout | packages/core/src/game/PotManager.bug.test.js > PotManager - Issue #11 Bug Fixed > should correctly create side pots when players go all-in

Pots after all betting:
Main Pot: {
  amount: [33m300[39m,
  eligible: [ [32m'p1'[39m, [32m'p2'[39m, [32m'p3'[39m ],
  isActive: [33mfalse[39m,
  maxContribution: [33m100[39m
}
Side Pot 1: {
  amount: [33m400[39m,
  eligible: [ [32m'p2'[39m, [32m'p3'[39m ],
  isActive: [33mfalse[39m,
  maxContribution: [33m300[39m
}

 âœ“ packages/core/src/game/PotManager.bug.test.js (1 test) 2ms
 âœ“ packages/core/src/integration/6player-simple-v2.test.js (1 test) 13ms

â¯â¯â¯â¯â¯â¯â¯ Failed Tests 3 â¯â¯â¯â¯â¯â¯â¯

 FAIL  packages/core/src/integration/elimination-ordering.test.js > Tournament Elimination Ordering (Issue #28) > should handle single elimination correctly (baseline test)
AssertionError: expected 230 to be 60 // Object.is equality

[32m- Expected[39m
[31m+ Received[39m

[32m- 60[39m
[31m+ 230[39m

 â¯ packages/core/src/integration/elimination-ordering.test.js:797:38
    795|     // Verify the winner received the pot
    796|     expect(events.winners).toHaveLength(1);
    797|     expect(events.winners[0].amount).toBe(60); // Both blinds (30 + 30)
       |                                      ^
    798| 
    799|     // Note: The current implementation may not update table player châ€¦

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[1/3]â¯

 FAIL  packages/core/src/integration/event-ordering-elimination.test.js > Event Ordering - Elimination (Issue #33) > should fire player:eliminated after hand:ended when player loses all chips
AssertionError: expected 150 to be 80 // Object.is equality

[32m- Expected[39m
[31m+ Received[39m

[32m- 80[39m
[31m+ 150[39m

 â¯ packages/core/src/integration/event-ordering-elimination.test.js:175:50
    173|     // Total pot = 50 + 50 = 100, but Player 1 gets back 20 (uncalled â€¦
    174|     // So Player 1 wins 80
    175|     expect(handEndedEvents[0].winners[0].amount).toBe(80);
       |                                                  ^
    176|   });
    177| });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[2/3]â¯

 FAIL  packages/core/src/integration/split-pot-simple-v2.test.js > Simple Split Pot Test (v2) > should handle 2-player all-in split pot scenario
AssertionError: expected 2000 to be 200 // Object.is equality

[32m- Expected[39m
[31m+ Received[39m

[32m- 200[39m
[31m+ 2000[39m

 â¯ packages/core/src/integration/split-pot-simple-v2.test.js:143:22
    141|     // Total winnings should equal the pot (200 chips)
    142|     const totalWon = winners.reduce((sum, w) => sum + w.amount, 0);
    143|     expect(totalWon).toBe(200);
       |                      ^
    144|   });
    145| });

â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯[3/3]â¯


 Test Files  3 failed | 60 passed (63)
      Tests  3 failed | 236 passed (239)
   Start at  17:32:49
   Duration  23.11s (transform 460ms, setup 0ms, collect 2.32s, tests 20.28s, environment 0ms, prepare 93ms)

